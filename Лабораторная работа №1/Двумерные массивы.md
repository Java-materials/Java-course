[Назад](https://github.com/Vladislav-Lyuminarskiy/Java-course/tree/master/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%E2%84%961)

# Двумерные массивы

1. В  матрице `А[1..N,1..M]` определить сумму каждой строки и строчку с минимальной суммой рассортировать.

2. В матрице `В[1..N,1..M]` переставить строки в порядке убывания количества отрицательных чисел в строке.

3. B матрице `С[1..N,1..M]` переставить столбцы по возрастанию сумм столбцов матрицы.

4. В матрице `D[1..N,1..M]` максимальный элемент заменить средним арифметическим элементов строки, в которой находится максимальный элемент. Поменять местами первую и последнюю строки.

5. В матрице `E[1..N,1..M]` в строках, содержащих ноль, расположить элементы по убыванию.

6. В матрице `F[1..N,1..N]` упорядочить элементы главной диагонали в порядке возрастания. Определить сумму элементов, лежащих под главной диагональю.

7. В матрице `A[1..N,1..M]` определить среднее арифметическое столбцов до среднего столбца и среднее арифметическое после среднего столбца (средний столбец не включать). Если `среднее`<sub>`1`</sub> меньше `среднего`<sub>`2`</sub>, то переставить столбцы местами (первый с последним, второй с предпоследним и т.д.).

8. В матрице `A[1..N, 1..N]` сумму элементов над главной диагональю поделить на сумму элементов под побочной диагональю. Побочную рассортировать по убыванию.

9. В матрице `A[1..N, 1..M]` упорядочить элементы столбца по убыванию, содержащего наибольшее количество отрицательных чисел.

10. По заданной квадратной матрице `D[1..N, 1..N]` построить массив `C[1..2 * N-1]`, элементы которого - максимумы элементов диагоналей, параллельных главной диагонали.

11. В матрице `A[1..N, 1..M]` определить максимальный элемент каждого столбца и записать их в массив. Новый массив рассортировать по возрастанию.

12. В матрице `A[1..N, 1..M]` определить сумму положительных чисел каждого столбца, записав их в новый массив. Новый массив рассортировать по убыванию.

13. В матрице `A[1..N, 1..M]` определить минимальный элемент каждой строки. Вывести строку с максимальным минимумом.

14. В матрице `A[1..N, 1..N]` поменять местами строки (первую с последней, вторую с предпоследней и т.д.). Элементы, лежащие на главной диагонали, не трогать.

15. В матрице `A[1..N, 1..M]` поменять столбцы, содержащие соответственно максимальный и минимальный элементы матрицы. Определить среднее арифметическое этих столбцов.

16. В матрице `A[1..N, 1..M]` вычислить сумму элементов, находящихся правее столбца с максимальным элементом матрицы, и среднее арифметическое элементов, расположенных ниже строки с максимальным элементом матрицы.

17. Составить массив `В` так, чтобы элементы массива `A[1..N, 1..N]` следовали в нем в последовательности диагоналей параллельно побочной диагонали и начинались с `A[1, 1]`, `A[2, 1]`, `A[1, 2]`, `A[3, 1]`, `A[2, 2]`, `A[1, 3]` и т.д.

18. Создать массив `В` из элементов строк матрицы `A[1..N, 1..M]`, в которых есть нулевые элементы и массив `С` - из элементов строк, в которых нулей нет. Вывести оба новых массива.

19. Создать матрицу `A[1..N, 1..M]`. Найти две строки, в которых элементы одинаковы, но могут стоять в различной последовательности.

20. Создать матрицу `A[1..N, 1..N]` из целых чисел. Сформировать массив, элементы которого - минимальные элементы диагоналей, параллельных побочной диагонали.

21. Создать матрицу `B[1..N, 1..M]` из целых чисел. Из каждой строки напечатать числа, которых нет в следующей строке. Числа эти записать построчно в новую матрицу, заполняя нулями недостающие значения до конца строки.

22. В матрице `C[1..N, 1..M]` целых чисел определить,есть ли седловая точка (седлом называется элемент матрицы минимальный в строке, и, одновременно, максимальный в столбце). Если такой элемент есть, вывести значение и его индексы.

23. Для созданной последовательности целых чисел `A[1], A[2], ..., A[n]` определить `T[i, j]` как сумму `A[k]`, где `k` изменяется от `i` до `j`. Найти `i`, `j` такие, что `T[i, j]` максимальна.

24. Получить матрицу `B[1..(N - 1), 1..(M - 1)]` из матрицы `A[1..N, 1..M]` удалением `n`-й строки и `k`- го столбца (`n` и `k` вводятся отдельно).

25. Вычеркнуть `k` строку и `m` столбец, содержащие минимальное значение матрицы `A[1..N,1..M]`, записав в новую матрицу `B[1..(N - 1), 1..(M - 1)]`.

26. Ввести число n и заполнить двумерный массив размером `n * n` числами `1, 2, 3, ...` по спирали во внутрь. Найти сумму на побочной диагонали.

27. На квадратном клетчатом листе бумаги размером `N * N` клеток нарисовано несколько прямоугольников. Каждый прямоугольник состоит из целых клеток и заполнен `1`. Остальное поле - `0`. Прямоугольники не накладываются друг на друга и не перекрываются. Определить количество прямоугольников.

28. Обнуление. В созданном двумерном массиве `A[1..M, 1..N]` заменить нулями элементы, стоящие в строках или столбцах, где имеются нули. Условие: можно создать вспомогательный одномерный массив, но нельзя создавать вспомогательный двумерный массив.

29. В матрице `A[1..N, 1..N]` проанализировать элемент, лежащий на главной диагонали. Если он равен нулю, то в этой строке определить минимальное значение, иначе эту строку рассортировать.

30. В матрице `A[1..N, 1..N]` если элемент, лежащий на побочной диагонали меньше нуля, то определить среднее арифметическое положительных чисел этого столбца, иначе этот столбец рассортировать.

31. Определить количество особых элементов массива `A[1..N, 1..M]`. Особым считается элемент, если он:
    1. больше суммы остальных элементов столбца,
    2. в его строке слева от него находятся элементы меньше его, а справа - больше.

32. Создать массив `A[1..2, 1..K]`. Известно, что среди его элементов два и только два равны между собой. Напечатать их значения и индексы. Одномерный массив не заводить.

33. Квадратики. Создать массив `A[1..M, 1..M]`, каждый элемент которого равен `0, 1, 5, 11`. Подсчитать в нем количество четверок `A[i, j], A[i + 1, j], A[i, j + 1], A[i + 1, j + 1]`, в каждой из которых все элементы различны.

34. Центральное селение. Имеется `k` селений. Если в селении `i` расположить пункт скорой помощи, то поездка по вызову в селение `j` займет время `A[i,i] + A[ i,j ] (1 <= i, j <= k, i <> j)`. Найти номер селения `i`, от которого поездка в самое удаленное (по времени) селение занимала бы минимальное время. Массив `A[1..k, 1..k]` создан. В нем все `A[i, j] > 0` и элемент `A[i, j]` может быть не равен элементу `A[j, i]` (алгоритм: в каждой строке `i` массива `А` выберем максимальное среди чисел `A[i, j] ( j <> i )` и сложим его с `A[i,i]`. Найти `i`, при котором соответствующая сумма будет минимальна).

35. Создать матрицу `A[1..N, 1..M]`. Упорядочить ее строки по убыванию:
    1. их первых элементов,
    2. суммы их элементов, 
    3. их наибольших элементов.

36. Определить, является ли созданная целая квадратная матрица `A[n * n]` симметричной относительно главной диагонали.

37. Определить, является ли созданная квадратная матрица `A[n * n]` магическим квадратом, т.е. такой, в которой суммы элементов во всех строках и столбцах одинаковы.

38. В матрице `A[1..N, 1..M]` переставить строки и столбцы таким образом, чтобы минимальный элемент встал в правый нижний угол матрицы, при этом последовательность чисел в строке (столбце) не изменялась, а только местоположение.

39. Построено 5 домов по 10 квартир в каждом. Сформировать массив `А`, где записать метраж квартир, в массив `В` записать число проживающих. Создать массив `С`, где будет указано число квартир каждого дома, где на одного проживающего - менее 7 метров.

40. Дана матрица `D[1..N, 1..M]`. Расставить элементы матрицы в возрастающем порядке слева направо, сверху вниз.

41. Элементами массива `A[1..N]` являются неубывающие массивы `[1..M]` целых чисел (т.е. двумерный массив `N * M` ). Известно, что существует число `х`, входящее во все массивы `A[i]`. Найти одно из таких чисел `х` (желательно за `M * N` действий).

42. Создать массив `N * N`, заполняя его числами от 1 до `N * N` по спирали во внутрь. Рассортировать строки по возрастанию сумм строк.

43. В матрице `A[1..N, 1..M]` переставить строки и столбцы таким образом, чтобы максимальный элемент встал в левый верхний угол матрицы, при этом последовательность чисел в строке (столбце) не изменилась, а только местоположение.

44. Создать матрицу `N * N` (где `N` - нечетно), заполняя его числами от 10 с шагом 10 в  последовательности индексов `[1, 1], [2, 1], [3, 1]` и т.д. по спирали. Определить сумму на главной и побочной диагоналях.

45. В двумерном массиве `A[N * N]` проанализировать элемент на побочной диагонали. Если он меньше или равен нулю, то эту строку рассортировать по возрастанию.

46. В двумерном массиве `А[N * N]` проанализировать элемент на главной диагонали. Если он больше нуля, то  найти сумму этого столбца.

47. В двумерном массиве `A[N * M]` проанализировать последний элемент в строке. Если он больше предшествующего, то найти минимальное этой строки, иначе найти максимальное этого столбца.

48. В двумерном массиве `N * N` определить максимальные значения на диагоналях, параллельных побочной диагонали и записать их в одномерный массив.

49. Из двумерного массива N*N записать числа в одномерный в последовательности `А[1, 1], А[1, 2], А[2, 1], А[3, 1], А[2, 2], А[1, 3]` и т.д. (т.е. змейкой).

50. Из двумерного массива `N * N` переписать числа в одномерный массив, начиная с `А[1, 1], А[1, 2], A[1, 3]` и т. д. Затем переходим на новую строку и начинаем записывать с конца к началу (т.е. змейкой по строкам). В одномерном массиве максимальное и минимальное числа поменять местами.
